<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>autostreamtree.genetic_distances API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>autostreamtree.genetic_distances</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import sys
import itertools
import numpy as np

import autostreamtree.aggregators as agg
import autostreamtree.sequence as seq


&#34;&#34;&#34;
Note several distance calculations not currently in use, I plan to expand this
further in the future, but for now only the following are supported:
- p distances
- Weir and Cockerham&#39;s Fst (linearised or non-linearised)
- Jost&#39;s D
- Chord distance
&#34;&#34;&#34;


def get_pop_genmat(dist, indmat, popmap, dat, seqs, pop_agg=&#34;ARITH&#34;,
                   loc_agg=&#34;ARITH&#34;, ploidy=2, global_het=False):
    # make matrix
    genmat = np.zeros((len(popmap), len(popmap)))
    # establish as nan
    genmat[:] = np.nan
    # for each combination, either average ind distances or calc freq dist
    for ia, ib in itertools.combinations(range(0, len(popmap)), 2):
        if dist in [&#34;PDIST&#34;]:
            inds1 = [dat.index(x) for x in popmap.values()[ia]]
            inds2 = [dat.index(x) for x in popmap.values()[ib]]
            genmat[ia, ib] = (agg.aggregate_dist(
                pop_agg, ([indmat[i, j] for i in inds1 for j in inds2]))
            )
            genmat[ib, ia] = genmat[ia, ib]
        elif dist == &#34;JOST&#34; or dist == &#34;HARMD&#34;:
            # Arrays to store Hs, Ht, and D for each locus
            hs_vals, ht_vals, d_vals = [], [], []
            gn = len(popmap)

            for loc in range(0, len(seqs[popmap.values()[ia][-1]])):
                seqs1 = get_alleles(
                    [seqs[x][loc] for x in popmap.values()[ia]])
                seqs2 = get_alleles(
                    [seqs[x][loc] for x in popmap.values()[ib]])
                if (not clean_list(set(seqs1), [&#34;n&#34;, &#34;N&#34;, &#34;-&#34;, &#34;?&#34;]) or
                        not clean_list(set(seqs2), [&#34;n&#34;, &#34;N&#34;, &#34;-&#34;, &#34;?&#34;])):
                    continue
                hs, ht, d = two_pop_jost_d(seqs1, seqs2, global_het)
                hs_vals.append(hs)
                ht_vals.append(ht)
                d_vals.append(d)

            if loc_agg not in (&#34;ARITH&#34;, &#34;HARM&#34;, &#34;ADJHARM&#34;):
                raise ValueError(&#34;Invalid aggregation method for loci.&#34;)

            # Aggregate the results for Hs and Ht
            global_hs = agg.aggregate_dist(loc_agg, hs_vals)
            global_ht = agg.aggregate_dist(loc_agg, ht_vals)
            hs_vals.append(global_hs)

            # Calculate global D
            if dist == &#34;JOST&#34;:
                if global_ht == 0:
                    global_d = 0.0
                else:
                    global_d = (global_ht - global_hs) / (1 - global_hs) * \
                        (gn / (gn - 1))
            else:
                if loc_agg in (&#34;HARM&#34;, &#34;ADJHARM&#34;):
                    global_d = agg.aggregate_dist(loc_agg, d_vals)
                else:
                    global_d = agg.aggregate_dist(&#34;HARM&#34;, d_vals)
            genmat[ia, ib] = genmat[ib, ia] = global_d

        # elif dist == &#34;GST&#34; or dist == &#34;GSTPRIME&#34;:
        #     HT = list()
        #     HS = list()
        #     for loc in range(0, len(seqs[popmap.values()[ia][-1]])):
        #         seqs1 = get_alleles(
        #             [seqs[x][loc] for x in popmap.values()[ia]]
        #         )
        #         seqs2 = get_alleles(
        #             [seqs[x][loc] for x in popmap.values()[ib]]
        #         )
        #         if (not clean_list(set(seqs1), [&#34;n&#34;, &#34;N&#34;, &#34;-&#34;, &#34;?&#34;]) or
        #                 not clean_list(set(seqs2), [&#34;n&#34;, &#34;N&#34;, &#34;-&#34;, &#34;?&#34;])):
        #             continue
        #         if dist == &#34;GST&#34; or &#34;GSTPRIME&#34;:
        #             (ht, hs) = two_pop_ht_hs(seqs1, seqs2, ploidy,global_het)
        #             HT.append(ht)
        #             HS.append(hs)
        #     Ht_global = np.mean(HT)
        #     Hs_global = np.mean(HS)
        #     if dist == &#34;GST&#34;:
        #         if Ht_global &lt;= 0.0:
        #             genmat[ia, ib] = genmat[ib, ia] = 0.0
        #         Gst = ((Ht_global - Hs_global) / Ht_global)
        #         GprimeST = ((Gst * (1.0 + Hs_global)) / (1.0 - Hs_global))
        #         genmat[ia, ib] = genmat[ib, ia] = GprimeST
        #     elif dist == &#34;GSTPRIME&#34;:
        #         Ghedrick = ((2.0*(Ht_global - Hs_global)) /
        #                     (((2.0*Ht_global) - Hs_global) *
        #                      (1.0 - Hs_global)))
        #         genmat[ia, ib] = genmat[ib, ia] = Ghedrick
        elif dist == &#34;FST&#34; or dist == &#34;LINFST&#34;:
            num = list()  # numerator; a
            denom = list()  # denominator; a*b*c
            for loc in range(0, len(seqs[popmap.values()[ia][-1]])):
                seqs1 = clean_inds([seqs[x][loc] for x in popmap.values()[ia]])
                seqs2 = clean_inds([seqs[x][loc] for x in popmap.values()[ib]])
                if (not all(&#34;/&#34; in x for x in seqs1) or
                        not all(&#34;/&#34; in x for x in seqs2)):
                    print(&#34;ERROR: FST estimates require phased data.&#34;)
                    sys.exit(1)
                if len(seqs1) == 0 or len(seqs2) == 0:
                    continue
                (n, d) = two_pop_weir_cockerham_fst(seqs1, seqs2)
                num.append(n)
                denom.append(d)

            # if either population lacking data, set value to nan
            if len(num) &lt;= 0 or len(denom) &lt;= 0:
                np.nan
            # if denominator is 0, set Fst to 0
            elif np.sum(denom) == 0.0:
                theta = 0.0
            # otherwise, calculate as normal
            else:
                theta = np.sum(num) / np.sum(denom)

            if dist == &#34;FST&#34;:
                genmat[ia, ib] = genmat[ib, ia] = theta
            elif dist == &#34;LINFST&#34;:
                if theta != 1.0:
                    genmat[ia, ib] = genmat[ib, ia] = (theta / (1-theta))
                else:
                    genmat[ia, ib] = genmat[ib, ia] = theta
        # elif dist == &#34;NEI83&#34;:
        #     results = list()
        #     loci = 0.0
        #     for loc in range(0, len(seqs[popmap.values()[ia][-1]])):
        #         seqs1 = get_alleles(
        #             [seqs[x][loc] for x in popmap.values()[ia]]
        #         )
        #         seqs2 = get_alleles(
        #             [seqs[x][loc] for x in popmap.values()[ib]]
        #         )
        #         if (not clean_list(set(seqs1), [&#34;n&#34;, &#34;N&#34;, &#34;-&#34;, &#34;?&#34;]) or
        #                 not clean_list(set(seqs2), [&#34;n&#34;, &#34;N&#34;, &#34;-&#34;, &#34;?&#34;])):
        #             continue
        #         loci += 1.0
        #         results.append(two_pop_nei_da(seqs1, seqs2))
        #     Da = (1.0 - (np.sum(results) / loci))
        #     genmat[ia, ib] = genmat[ib, ia] = Da
        elif dist == &#34;CHORD&#34;:
            sum_squares = 0.0
            for loc in range(0, len(seqs[popmap.values()[ia][-1]])):
                seqs1 = get_alleles(
                    [seqs[x][loc] for x in popmap.values()[ia]])
                seqs2 = get_alleles(
                    [seqs[x][loc] for x in popmap.values()[ib]])

                if (not clean_list(set(seqs1), [&#34;n&#34;, &#34;N&#34;, &#34;-&#34;, &#34;?&#34;]) or
                        not clean_list(set(seqs2), [&#34;n&#34;, &#34;N&#34;, &#34;-&#34;, &#34;?&#34;])):
                    continue

                sq_diff, _ = two_pop_chord_dist(seqs1, seqs2)
                sum_squares += sq_diff
            Dch = np.sqrt(sum_squares)
            genmat[ia, ib] = genmat[ib, ia] = Dch
        else:
            raise ValueError(f&#34;Unsupported distance option {dist}&#34;)
    np.fill_diagonal(genmat, 0.0)
    if 0.0 in genmat:
        print(&#34;WARNING: Coercing negative distances to 0.0&#34;)
        genmat[genmat &lt; 0.0] = 0.0
    return genmat


# function computes pairwise p-distance or JC69-corrected distances
def get_genmat(dist, points, seqs, ploidy, het, loc_agg):
    # make matrix
    genmat = np.zeros((len(points), len(points)))
    # establish as nan
    genmat[:] = np.nan

    # NOT USED CURRENTLY
    # for models which relax equal nuc frequencies, get global frequencies
    # for each locus
    # freqs will be a list of loci, with each locus as a dist of freqs
    # if dist in [&#34;TN84&#34;, &#34;TN93&#34;]:
    #     freqs = seq.get_nuc_freqs(seqs, ploidy)
    #     index = 1
    #     for f in freqs:
    #         print(&#34;Empirical base frequencies for locus&#34;,index, end=&#34;: [ &#34;)
    #         for n in f:
    #             print(f&#39;{n}={f[n]:.3f} &#39;, end=&#34;&#34;)
    #         print(&#34;]&#34;)
    #         index = index + 1

    # for each combination, calc jukes-cantor corrected distance
    for ia, ib in itertools.combinations(range(0, len(points)), 2):
        results = list()
        for loc in range(0, len(seqs[points.keys()[ia]])):
            seq1 = seqs[points.keys()[ia]][loc]
            seq2 = seqs[points.keys()[ib]][loc]
            if &#34;/&#34; in seq1:
                seq1 = seq.dna_consensus(seq1)
            if &#34;/&#34; in seq2:
                seq2 = seq.dna_consensus(seq2)
            if dist == &#34;PDIST&#34;:
                if het:
                    results.append(p_distance(seq1, seq2))
                else:
                    results.append(hamming_distance(seq1, seq2))
            else:
                raise ValueError(f&#34;{dist} not implemented&#34;)
        # aggregate results across loci
        genmat[ia, ib] = agg.aggregate_dist(loc_agg, results)
        genmat[ib, ia] = genmat[ia, ib]
    # fill diagonals
    np.fill_diagonal(genmat, 0.0)
    return genmat


# NOT IN USE
# def jukes_cantor_distance(seq1: str, seq2: str, het: bool = False) -&gt; float:
#     &#34;&#34;&#34;
#     Description: This function calculates the JC69-corrected p-distance
#                  between two DNA sequences.

#     Args:
#     - seq1 (str): The first DNA sequence.
#     - seq2 (str): The second DNA sequence.
#     - het (bool): Whether to use the Jukes-Cantor correction for heterozygous
#                   sites (True) or for all sites (False). Default is False.

#     Returns:
#     - dist (float): The JC69-corrected p-distance between the two sequences.
#     &#34;&#34;&#34;
#     obs = 0.0
#     # calculate the observed distance
#     if het:
#         obs = p_distance(seq1, seq2)
#     else:
#         obs = hamming_distance(seq1, seq2)

#     # apply the JC69 correction
#     if obs &gt;= 0.74999:
#         obs = 0.749
#     dist = -0.75 * np.log(1.0 - ((4.0/3.0) * obs))

#     # ensure distance is not negative and return
#     if not dist &gt; 0.0:
#         return 0.0
#     return dist


# NOT IN USE
# # function to return Kimura 2-parameter distances
# def k2p_distance(seq1, seq2, het=False):
#     &#34;&#34;&#34;
#     Computes the Kimura 2-parameter distance between two DNA sequences.

#     Args:
#     - seq1 (str): The first DNA sequence to compare.
#     - seq2 (str): The second DNA sequence to compare.
#     - het (bool): Whether to use the p-distance or Jukes-Cantor distance.
#                   Defaults to False (Jukes-Cantor distance).

#     Returns:
#     - dist (float): The Kimura 2-parameter distance between the two sequences
#     &#34;&#34;&#34;
#     P = 0.0
#     Q = 0.0
#     if het:
#         (P, Q) = p_distance(seq1, seq2, trans=True)
#     else:
#         (P,Q)=hamming_distance(seq1, seq2, trans=True)

#     dist=-0.5*(np.log((1.0-(2.0*P)-Q) * math.sqrt(1.0-(2.0*Q))))
#     #print(dist)
#     if dist &lt;= 0.0:
#         return(0.0)
#     return(dist)


# NOT IN USE
# def tn84_distance(seq1: str, seq2: str, freqs: Dict[str, float], het:
#                   bool = False) -&gt; float:
#     &#34;&#34;&#34;
#     Compute the TN84 distance between two DNA sequences.

#     Args:
#     seq1: str
#         A DNA sequence.
#     seq2: str
#         Another DNA sequence.
#     freqs: Dict[str, float]
#         A dictionary containing the frequency of each nucleotide.
#         For example, {&#39;A&#39;: 0.3, &#39;C&#39;: 0.2, &#39;G&#39;: 0.2, &#39;T&#39;: 0.3}.
#     het: bool, optional (default=False)
#         Indicates whether heterozygosity is used.

#     Returns:
#     dist: float
#         TN84 distance between seq1 and seq2.

#     &#34;&#34;&#34;
#     D=0.0
#     if het:
#         D=p_distance(seq1, seq2, trans=False)
#     else:
#         D=hamming_distance(seq1, seq2, trans=False)

#     ss=0.0
#     for n in freqs:
#         ss = ss + np.square(freqs[n])
#     b=float(1.0-ss)
#     dist=-b*np.log(1.0-((1.0/b)*D))
#     #print(dist)
#     if dist &lt;= 0.0:
#         return(0.0)
#     return(dist)


# NOT IN USE
# def tn93_distance(seq1: str, seq2: str, freqs: Dict[str, float],
#                   het: bool = False) -&gt; float:
#     &#34;&#34;&#34;
#     Compute TN93 distances between two sequences.

#     Args:
#         seq1: A DNA sequence.
#         seq2: A DNA sequence.
#         freqs: A dictionary of nucleotide frequencies, where the keys are
#                nucleotides (A, T, C, G)
#                and the values are the frequency of the corresponding nucleoti
#                in the alignment.
#         het: Whether the nucleotide differences are considered heterozygous.
#              Default is False.

#     Returns:
#         The TN93 distance between the two input sequences.

#     &#34;&#34;&#34;

#     P1 = 0.0
#     P2 = 0.0
#     Q = 0.0
#     if het:
#         P1, P2, Q = p_distance(seq1, seq2, trans=False, transSplit=True)
#     else:
#         P1, P2, Q = hamming_distance(seq1, seq2, trans=False,transSplit=True)

#     # Calculate nucleotide frequencies
#     gR = freqs[&#39;g&#39;] + freqs[&#39;a&#39;]
#     gY = freqs[&#39;c&#39;] + freqs[&#39;t&#39;]

#     # Calculate k values
#     k1 = (2.0 * (freqs[&#39;a&#39;] * freqs[&#39;g&#39;])) / gR
#     k2 = (2.0 * (freqs[&#39;t&#39;] * freqs[&#39;c&#39;])) / gY
#     k3 = 2.0 * ((gR * gY) - ((freqs[&#39;a&#39;] * freqs[&#39;g&#39;] * gY) / gR) -
#                 ((freqs[&#39;t&#39;] * freqs[&#39;c&#39;] * gR) / gY))

#     # Calculate weight values
#     w1 = 1.0 - (P1 / k1) - (Q / (2.0 * gR))
#     w2 = 1.0 - (P2 / k3) - (Q / (2.0 * gY))
#     w3 = 1.0 - (Q / (2.0 * gR * gY))

#     # Calculate the distance
#     dist = -(k1 * np.log(w1)) - (k2 * np.log(w2)) - (k2 * np.log(w3))

#     # Check for negative or NaN distances
#     if dist &lt;= 0.0 or np.isnan(dist):
#         return 0.0

#     return dist


# p distance = D / L (differences / length)
# L is the UNGAPPED distance
# ambigs are expanded
# when trans = true, returns two values:
# P (transitions/L) and Q (transversions/L)
def p_distance(seq1, seq2):
    &#34;&#34;&#34;
    Calculate p-distance, accounting for IUPAC ambiguity codes and partial
    matches.

    Args:
        seq1 (str): First sequence.
        seq2 (str): Second sequence.

    Returns:
        float: p-distance.
    &#34;&#34;&#34;
    L = min(len(seq1), len(seq2))
    D = 0.0

    for n1, n2 in zip(seq1.lower(), seq2.lower()):
        if n1 in [&#34;?&#34;, &#34;-&#34;, &#34;n&#34;] or n2 in [&#34;?&#34;, &#34;-&#34;, &#34;n&#34;]:
            L -= 1
            continue
        else:
            ex1 = set(seq.get_iupac_caseless(n1))
            ex2 = set(seq.get_iupac_caseless(n2))

            if ex1 == ex2:
                # Exact match
                continue
            elif ex1.isdisjoint(ex2):
                # No match
                D += 1.0
            else:
                # Partial match
                D += 0.5

    if L &lt;= 0:
        return 0.0
    return D / L


# p distance = D / L (differences / length)
# gaps ignored
# ambigs are treated as alleles
def hamming_distance(seq1, seq2):
    &#34;&#34;&#34;
    Calculate the Hamming distance between two sequences.

    Args:
        seq1 (str): First sequence.
        seq2 (str): Second sequence.

    Returns:
        float: Hamming distance.
    &#34;&#34;&#34;
    # Ensure sequences are of equal length
    L = min(len(seq1), len(seq2))
    D = 0.0

    for n1, n2 in zip(seq1.lower(), seq2.lower()):
        if n1 in [&#34;?&#34;, &#34;-&#34;, &#34;n&#34;] or n2 in [&#34;?&#34;, &#34;-&#34;, &#34;n&#34;]:
            L -= 1  # Ignore positions with gaps or ambiguous nucleotides
        elif n1 != n2:
            D += 1.0  # Count mismatches

    if L &lt;= 0:
        return 0.0  # Avoid division by zero
    return D / L


# NOT IN USE
# def two_pop_nei_da(s1: List[str], s2: List[str]) -&gt; float:
#     &#34;&#34;&#34;
#     Computes Nei&#39;s 1983 Da estimator for two populations.

#     Args:
#         s1 (List[str]): A list of phased genotypes from population 1,
# e.g. [&#39;A/A&#39;, &#39;A/B&#39;, &#39;B/B&#39;, ...].
#         s2 (List[str]): A list of phased genotypes from population 2,
# e.g. [&#39;A/A&#39;, &#39;A/C&#39;, &#39;C/C&#39;, ...].
#     Returns:
#         float: The Nei&#39;s 1983 Da estimator.
#     &#34;&#34;&#34;
#     # Clean the input lists by removing individuals with unknown or gap
# alleles.
#     s1 = clean_list(s1, [&#34;n&#34;, &#34;?&#34;, &#34;-&#34;, &#34;N&#34;])
#     s2 = clean_list(s2, [&#34;n&#34;, &#34;?&#34;, &#34;-&#34;, &#34;N&#34;])
#     # Get the list of unique alleles from both populations.
#     uniques = uniq_alleles(s1+s2)
#     # Compute the sum of squared roots of frequencies for each allele.
#     sumSqRt = 0.0
#     for allele in uniques:
#         if allele in [&#34;-&#34;, &#34;?&#34;, &#34;n&#34;, &#34;N&#34;]:
#             continue
#         else:
#             Xu = float(s1.count(allele) / len(s1))
#             Yu = float(s2.count(allele) / len(s2))
#             sumSqRt += np.sqrt(Xu*Yu)
#     return sumSqRt


# NOT IN USE
# def two_pop_euclid_dist(s1: List[str], s2: List[str]) -&gt; float:
#     &#34;&#34;&#34;
#     Computes Euclidean distance between two populations for a single locus.

#     Args:
#     - s1 (List[str]): List of allele calls for population 1 at a given locus
#     - s2 (List[str]): List of allele calls for population 2 at a given locus

#     Returns:
#     - Euclidean distance between the two populations for the given locus

#     &#34;&#34;&#34;
#     # Get unique alleles in the two populations
#     uniques = seq.uniq_alleles(s1+s2)
#     # Clean the sequences by removing any unknown or gap alleles
#     s1 = clean_list(s1, [&#34;n&#34;, &#34;?&#34;, &#34;-&#34;, &#34;N&#34;])
#     s2 = clean_list(s2, [&#34;n&#34;, &#34;?&#34;, &#34;-&#34;, &#34;N&#34;])
#     # Calculate Euclidean distance
#     sumSq = 0.0
#     for allele in uniques:
#         if allele in [&#34;-&#34;, &#34;?&#34;, &#34;n&#34;, &#34;N&#34;]:
#             continue
#         else:
#             Xu = float(s1.count(allele) / len(s1))
#             Yu = float(s2.count(allele) / len(s2))
#             sumSq += np.square(Xu - Yu)
#     return sumSq


# Cavalli-Sforza and Edwards 1967 chord distance
# non-nucleotide alleles are deleted
def two_pop_chord_dist(s1, s2):
    s1 = clean_list(s1, [&#34;n&#34;, &#34;?&#34;, &#34;-&#34;, &#34;N&#34;])
    s2 = clean_list(s2, [&#34;n&#34;, &#34;?&#34;, &#34;-&#34;, &#34;N&#34;])
    uniques = uniq_alleles(s1 + s2)

    sum_squares = 0.0
    for allele in uniques:
        if allele in [&#34;-&#34;, &#34;?&#34;, &#34;n&#34;, &#34;N&#34;]:
            continue
        Xu = float(s1.count(allele) / len(s1))
        Yu = float(s2.count(allele) / len(s2))
        sum_squares += np.square(Xu - Yu)

    return sum_squares, len(uniques)


def two_pop_weir_cockerham_fst(s1, s2):
    &#34;&#34;&#34;
    Computes Weir and Cockerham&#39;s THETAst Fst approximation for two populations

    Args:
        s1 (list): A list of phased genotypes for population 1.
        s2 (list): A list of phased genotypes for population 2.

    Returns:
        tuple: A tuple containing two floats. The first float is the numerator
        of the THETAst estimator for the locus. The second float is the
        denominator of the THETAst estimator for the locus.

    Raises:
        ValueError: If the inputs are not valid.

    &#34;&#34;&#34;
    # Check inputs
    if not isinstance(s1, list) or not isinstance(s2, list):
        raise ValueError(&#34;Inputs must be lists.&#34;)
    if not s1 or not s2:
        raise ValueError(&#34;Inputs must not be empty.&#34;)
    if (not all(isinstance(x, str) for x in s1) or
            not all(isinstance(x, str) for x in s2)):
        raise ValueError(&#34;Inputs must only contain strings.&#34;)
    if not all(&#34;/&#34; in x for x in s1) or not all(&#34;/&#34; in x for x in s2):
        raise ValueError(&#34;Inputs must be phased genotypes.&#34;)

    # Initialize variables
    num = 0.0
    denom = 0.0

    # mean sample size
    alleles1 = get_alleles(s1)  # split alleles s1
    alleles2 = get_alleles(s2)  # split alleles s2
    uniques = uniq_alleles(s1+s2)  # list of unique alleles only
    r = 2.0  # number of pops
    n1 = float(len(s1))  # pop size of pop 1
    n2 = float(len(s2))  # pop size of pop 2
    csd = np.std([n1, n2])
    cm = np.mean([n1, n2])
    nbar = cm
    csquare = (csd*csd) / (cm*cm)
    nC = nbar * (1.0 - (csquare/r))  # coeff of pop size variance
    for allele in uniques:
        ac1 = float(alleles1.count(allele))
        ac2 = float(alleles2.count(allele))
        p1 = ac1 / float(len(alleles1))
        p2 = ac2 / float(len(alleles2))
        h1 = get_het_from_phased(allele, s1, count=True)
        h2 = get_het_from_phased(allele, s2, count=True)
        pbar = (ac1+ac2) / (float(len(alleles1)) + float(len(alleles2)))
        ssquare = ((np.sum([(n1 * (np.square(p1 - pbar))),
                            (n2 * (np.square(p2 - pbar)))])) / ((r-1.0)*nbar))
        hbar = ((h1 + h2) / (r * nbar))
        if nbar != 1.0:
            a = ((nbar/nC) * (ssquare -
                              ((1.0 / (nbar-1.0)) *
                               ((pbar * (1.0 - pbar)) -
                                ((r - 1.0) * ssquare / r) -
                                (hbar / 4.0)))))
            b = ((nbar / (nbar-1.0)) *
                 ((pbar * (1.0 - pbar)) -
                  ((r - 1.0) * ssquare / r) -
                  (((2.0 * nbar) - 1.0) * hbar / (4.0 * nbar))))
            c = hbar/2.0
            d = a+b+c
            num += a
            denom += d
    return num, denom


def clean_inds(inds):
    &#34;&#34;&#34;
    Removes individuals with unknown or gap alleles.

    Args:
        inds (list): A list of individuals.

    Returns:
        list: A list of individuals without unknown or gap alleles.
    &#34;&#34;&#34;
    ret = []
    for ind in inds:
        if (&#34;-&#34; not in ind and &#34;?&#34; not in ind and &#34;n&#34; not in ind and
                &#34;N&#34; not in ind):
            ret.append(ind)
    return ret


def two_pop_jost_d(seqs1, seqs2, global_het=False):
    if global_het:
        Ht = get_global_het(seqs1 + seqs2)
    else:
        Ht = get_average_het(seqs1, seqs2)
    Hs = np.mean([get_global_het(seqs1), get_global_het(seqs2)])
    n = len(seqs1 + seqs2)
    D = (Ht - Hs) / (1 - Hs) * (n / (n - 1))
    return Hs, Ht, D


# NOT IN USE
# def two_pop_ht_hs(seqs1, seqs2, ploidy, global_het=False):
#     &#34;&#34;&#34;
#     Computes Nei&#39;s Fst estimator (Gst) using Nei and Chessers Hs and Ht
# estimators
#     also applies Hedrick&#39;s (2005) sample size correction, thus returning
# G&#39;st.

#     Args:
#     - seqs1, seqs2 (list): lists of sequences for populations 1 and 2.
#     - ploidy (int): ploidy of the sequences.
#     - global_het (bool, optional): If True, computes global heterozygosity.
# Defaults to False.

#     Returns:
#     - A tuple containing Ht_est and Hs_est.

#     &#34;&#34;&#34;
#     if global_het:
#         Ht = get_global_het(seqs1 + seqs2)
#     else:
#         Ht = get_average_het(seqs1, seqs2)

#     Hs = np.mean([get_global_het(seqs1), get_global_het(seqs2)])
#     harmN = scipy.stats.hmean([(len(seqs1) / ploidy), (len(seqs1) / ploidy)])

#     # Hs correction based on Hedrick (2005)
#     Hs_est = Hs * ((2.0 * harmN) / ((2.0 * harmN) - 1.0))

#     # Ht correction based on Hedrick (2005)
#     Ht_est = Ht + (Hs / (harmN * 2.0 * 2.0))

#     # Gst = ((Ht_est - Hs_est) / Ht_est )

#     # GprimeST = ((Gst * (1.0 + Hs_est)) / (1.0 - Hs_est))
#     return (Ht_est, Hs_est)


def get_het_from_phased(allele, phasedList, count=False):
    &#34;&#34;&#34;
    Returns observed heterozygosity of an allele given a list of phased
    genotypes (e.g. allele1/allele2 for each individual). Assumes diploid.

    Args:
    allele (str): The allele for which to compute heterozygosity.
    phasedList (list): A list of phased genotypes, where each element is a
                       string of the form &#39;allele1/allele2&#39;.
    count (bool): Whether to return the number of heterozygotes instead of the
                  proportion.

    Returns:
    float: The proportion of heterozygotes for the given allele, unless `count`
           is True, in which case the count of heterozygotes is returned.
    &#34;&#34;&#34;
    hets = 0.0
    twoN = (len(phasedList)) * 2.0
    for genotype in phasedList:
        if &#34;/&#34; not in genotype:
            print(
                &#34;ERROR (get_het_from_phased): Phased genotypes are required.&#34;
            )
        gens = genotype.split(&#34;/&#34;)
        if gens[0] == allele and gens[1] != allele:
            hets += 1.0
            continue
        elif gens[1] == allele and gens[0] != allele:
            hets += 1.0
            continue
        else:
            continue
    if count:
        return hets
    else:
        return hets / twoN


def get_global_het(seqs):
    &#34;&#34;&#34;
    Computes global expected heterozygosity (Ht) from a set of sequences.

    Args:
    seqs (list): A list of sequences.

    Returns:
    float: The Ht estimate for the given sequences.
    &#34;&#34;&#34;
    hom = 0.0
    uniq_alleles = clean_list(set(seqs), [&#34;n&#34;, &#34;?&#34;, &#34;-&#34;, &#34;N&#34;])
    freqs = [np.square(float(seqs.count(x) / len(seqs))) for x in uniq_alleles]
    hom = np.sum(freqs)
    return 1.0 - hom


def get_average_het(s1, s2):
    &#34;&#34;&#34;Computes the mean expected heterozygosity (Ht) from two populations.

    Args:
        s1 (list): A list of alleles from population 1.
        s2 (list): A list of alleles from population 2.

    Returns:
        float: The Ht estimate per locus.
    &#34;&#34;&#34;
    hom = 0.0
    # Get unique alleles
    uniq_alleles = clean_list(set(s1+s2), [&#34;n&#34;, &#34;?&#34;, &#34;-&#34;, &#34;N&#34;])
    # Compute frequency for each allele
    freqs = [np.square(
        np.mean([float(s1.count(x)/len(s1)),
                 float(s2.count(x)/len(s2))])) for x in uniq_alleles]
    hom = np.sum(freqs)
    return 1.0 - hom


def clean_list(to_clean, bads):
    &#34;&#34;&#34;Removes bad items from a list.

    Args:
        l (list): A list to clean.
        bads (list): A list of items to remove.

    Returns:
        list: A cleaned list.
    &#34;&#34;&#34;
    if not any(item not in bads for item in set(to_clean)):
        return False
    for b in bads:
        if b in to_clean:
            to_clean.remove(b)
    return to_clean


def get_alleles(s):
    &#34;&#34;&#34;Splits a string of alleles separated by &#34;/&#34; into a list.

    Args:
        s (str): A string of alleles separated by &#34;/&#34;.

    Returns:
        list: A list of alleles.
    &#34;&#34;&#34;
    return sum([x.split(&#34;/&#34;) for x in s], [])


def uniq_alleles(s):
    &#34;&#34;&#34;Returns the unique alleles in a list of alleles.

    Args:
        s (list): A list of alleles.

    Returns:
        set: A set of unique alleles.
    &#34;&#34;&#34;
    return set(sum([x.split(&#34;/&#34;) for x in s], []))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="autostreamtree.genetic_distances.clean_inds"><code class="name flex">
<span>def <span class="ident">clean_inds</span></span>(<span>inds)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes individuals with unknown or gap alleles.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>inds</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of individuals.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>A list of individuals without unknown or gap alleles.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean_inds(inds):
    &#34;&#34;&#34;
    Removes individuals with unknown or gap alleles.

    Args:
        inds (list): A list of individuals.

    Returns:
        list: A list of individuals without unknown or gap alleles.
    &#34;&#34;&#34;
    ret = []
    for ind in inds:
        if (&#34;-&#34; not in ind and &#34;?&#34; not in ind and &#34;n&#34; not in ind and
                &#34;N&#34; not in ind):
            ret.append(ind)
    return ret</code></pre>
</details>
</dd>
<dt id="autostreamtree.genetic_distances.clean_list"><code class="name flex">
<span>def <span class="ident">clean_list</span></span>(<span>to_clean, bads)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes bad items from a list.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>l</code></strong> :&ensp;<code>list</code></dt>
<dd>A list to clean.</dd>
<dt><strong><code>bads</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of items to remove.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>A cleaned list.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean_list(to_clean, bads):
    &#34;&#34;&#34;Removes bad items from a list.

    Args:
        l (list): A list to clean.
        bads (list): A list of items to remove.

    Returns:
        list: A cleaned list.
    &#34;&#34;&#34;
    if not any(item not in bads for item in set(to_clean)):
        return False
    for b in bads:
        if b in to_clean:
            to_clean.remove(b)
    return to_clean</code></pre>
</details>
</dd>
<dt id="autostreamtree.genetic_distances.get_alleles"><code class="name flex">
<span>def <span class="ident">get_alleles</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"><p>Splits a string of alleles separated by "/" into a list.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>str</code></dt>
<dd>A string of alleles separated by "/".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>A list of alleles.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_alleles(s):
    &#34;&#34;&#34;Splits a string of alleles separated by &#34;/&#34; into a list.

    Args:
        s (str): A string of alleles separated by &#34;/&#34;.

    Returns:
        list: A list of alleles.
    &#34;&#34;&#34;
    return sum([x.split(&#34;/&#34;) for x in s], [])</code></pre>
</details>
</dd>
<dt id="autostreamtree.genetic_distances.get_average_het"><code class="name flex">
<span>def <span class="ident">get_average_het</span></span>(<span>s1, s2)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the mean expected heterozygosity (Ht) from two populations.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>s1</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of alleles from population 1.</dd>
<dt><strong><code>s2</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of alleles from population 2.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>The Ht estimate per locus.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_average_het(s1, s2):
    &#34;&#34;&#34;Computes the mean expected heterozygosity (Ht) from two populations.

    Args:
        s1 (list): A list of alleles from population 1.
        s2 (list): A list of alleles from population 2.

    Returns:
        float: The Ht estimate per locus.
    &#34;&#34;&#34;
    hom = 0.0
    # Get unique alleles
    uniq_alleles = clean_list(set(s1+s2), [&#34;n&#34;, &#34;?&#34;, &#34;-&#34;, &#34;N&#34;])
    # Compute frequency for each allele
    freqs = [np.square(
        np.mean([float(s1.count(x)/len(s1)),
                 float(s2.count(x)/len(s2))])) for x in uniq_alleles]
    hom = np.sum(freqs)
    return 1.0 - hom</code></pre>
</details>
</dd>
<dt id="autostreamtree.genetic_distances.get_genmat"><code class="name flex">
<span>def <span class="ident">get_genmat</span></span>(<span>dist, points, seqs, ploidy, het, loc_agg)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_genmat(dist, points, seqs, ploidy, het, loc_agg):
    # make matrix
    genmat = np.zeros((len(points), len(points)))
    # establish as nan
    genmat[:] = np.nan

    # NOT USED CURRENTLY
    # for models which relax equal nuc frequencies, get global frequencies
    # for each locus
    # freqs will be a list of loci, with each locus as a dist of freqs
    # if dist in [&#34;TN84&#34;, &#34;TN93&#34;]:
    #     freqs = seq.get_nuc_freqs(seqs, ploidy)
    #     index = 1
    #     for f in freqs:
    #         print(&#34;Empirical base frequencies for locus&#34;,index, end=&#34;: [ &#34;)
    #         for n in f:
    #             print(f&#39;{n}={f[n]:.3f} &#39;, end=&#34;&#34;)
    #         print(&#34;]&#34;)
    #         index = index + 1

    # for each combination, calc jukes-cantor corrected distance
    for ia, ib in itertools.combinations(range(0, len(points)), 2):
        results = list()
        for loc in range(0, len(seqs[points.keys()[ia]])):
            seq1 = seqs[points.keys()[ia]][loc]
            seq2 = seqs[points.keys()[ib]][loc]
            if &#34;/&#34; in seq1:
                seq1 = seq.dna_consensus(seq1)
            if &#34;/&#34; in seq2:
                seq2 = seq.dna_consensus(seq2)
            if dist == &#34;PDIST&#34;:
                if het:
                    results.append(p_distance(seq1, seq2))
                else:
                    results.append(hamming_distance(seq1, seq2))
            else:
                raise ValueError(f&#34;{dist} not implemented&#34;)
        # aggregate results across loci
        genmat[ia, ib] = agg.aggregate_dist(loc_agg, results)
        genmat[ib, ia] = genmat[ia, ib]
    # fill diagonals
    np.fill_diagonal(genmat, 0.0)
    return genmat</code></pre>
</details>
</dd>
<dt id="autostreamtree.genetic_distances.get_global_het"><code class="name flex">
<span>def <span class="ident">get_global_het</span></span>(<span>seqs)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes global expected heterozygosity (Ht) from a set of sequences.</p>
<p>Args:
seqs (list): A list of sequences.</p>
<p>Returns:
float: The Ht estimate for the given sequences.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_global_het(seqs):
    &#34;&#34;&#34;
    Computes global expected heterozygosity (Ht) from a set of sequences.

    Args:
    seqs (list): A list of sequences.

    Returns:
    float: The Ht estimate for the given sequences.
    &#34;&#34;&#34;
    hom = 0.0
    uniq_alleles = clean_list(set(seqs), [&#34;n&#34;, &#34;?&#34;, &#34;-&#34;, &#34;N&#34;])
    freqs = [np.square(float(seqs.count(x) / len(seqs))) for x in uniq_alleles]
    hom = np.sum(freqs)
    return 1.0 - hom</code></pre>
</details>
</dd>
<dt id="autostreamtree.genetic_distances.get_het_from_phased"><code class="name flex">
<span>def <span class="ident">get_het_from_phased</span></span>(<span>allele, phasedList, count=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns observed heterozygosity of an allele given a list of phased
genotypes (e.g. allele1/allele2 for each individual). Assumes diploid.</p>
<p>Args:
allele (str): The allele for which to compute heterozygosity.
phasedList (list): A list of phased genotypes, where each element is a
string of the form 'allele1/allele2'.
count (bool): Whether to return the number of heterozygotes instead of the
proportion.</p>
<p>Returns:
float: The proportion of heterozygotes for the given allele, unless <code>count</code>
is True, in which case the count of heterozygotes is returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_het_from_phased(allele, phasedList, count=False):
    &#34;&#34;&#34;
    Returns observed heterozygosity of an allele given a list of phased
    genotypes (e.g. allele1/allele2 for each individual). Assumes diploid.

    Args:
    allele (str): The allele for which to compute heterozygosity.
    phasedList (list): A list of phased genotypes, where each element is a
                       string of the form &#39;allele1/allele2&#39;.
    count (bool): Whether to return the number of heterozygotes instead of the
                  proportion.

    Returns:
    float: The proportion of heterozygotes for the given allele, unless `count`
           is True, in which case the count of heterozygotes is returned.
    &#34;&#34;&#34;
    hets = 0.0
    twoN = (len(phasedList)) * 2.0
    for genotype in phasedList:
        if &#34;/&#34; not in genotype:
            print(
                &#34;ERROR (get_het_from_phased): Phased genotypes are required.&#34;
            )
        gens = genotype.split(&#34;/&#34;)
        if gens[0] == allele and gens[1] != allele:
            hets += 1.0
            continue
        elif gens[1] == allele and gens[0] != allele:
            hets += 1.0
            continue
        else:
            continue
    if count:
        return hets
    else:
        return hets / twoN</code></pre>
</details>
</dd>
<dt id="autostreamtree.genetic_distances.get_pop_genmat"><code class="name flex">
<span>def <span class="ident">get_pop_genmat</span></span>(<span>dist, indmat, popmap, dat, seqs, pop_agg='ARITH', loc_agg='ARITH', ploidy=2, global_het=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pop_genmat(dist, indmat, popmap, dat, seqs, pop_agg=&#34;ARITH&#34;,
                   loc_agg=&#34;ARITH&#34;, ploidy=2, global_het=False):
    # make matrix
    genmat = np.zeros((len(popmap), len(popmap)))
    # establish as nan
    genmat[:] = np.nan
    # for each combination, either average ind distances or calc freq dist
    for ia, ib in itertools.combinations(range(0, len(popmap)), 2):
        if dist in [&#34;PDIST&#34;]:
            inds1 = [dat.index(x) for x in popmap.values()[ia]]
            inds2 = [dat.index(x) for x in popmap.values()[ib]]
            genmat[ia, ib] = (agg.aggregate_dist(
                pop_agg, ([indmat[i, j] for i in inds1 for j in inds2]))
            )
            genmat[ib, ia] = genmat[ia, ib]
        elif dist == &#34;JOST&#34; or dist == &#34;HARMD&#34;:
            # Arrays to store Hs, Ht, and D for each locus
            hs_vals, ht_vals, d_vals = [], [], []
            gn = len(popmap)

            for loc in range(0, len(seqs[popmap.values()[ia][-1]])):
                seqs1 = get_alleles(
                    [seqs[x][loc] for x in popmap.values()[ia]])
                seqs2 = get_alleles(
                    [seqs[x][loc] for x in popmap.values()[ib]])
                if (not clean_list(set(seqs1), [&#34;n&#34;, &#34;N&#34;, &#34;-&#34;, &#34;?&#34;]) or
                        not clean_list(set(seqs2), [&#34;n&#34;, &#34;N&#34;, &#34;-&#34;, &#34;?&#34;])):
                    continue
                hs, ht, d = two_pop_jost_d(seqs1, seqs2, global_het)
                hs_vals.append(hs)
                ht_vals.append(ht)
                d_vals.append(d)

            if loc_agg not in (&#34;ARITH&#34;, &#34;HARM&#34;, &#34;ADJHARM&#34;):
                raise ValueError(&#34;Invalid aggregation method for loci.&#34;)

            # Aggregate the results for Hs and Ht
            global_hs = agg.aggregate_dist(loc_agg, hs_vals)
            global_ht = agg.aggregate_dist(loc_agg, ht_vals)
            hs_vals.append(global_hs)

            # Calculate global D
            if dist == &#34;JOST&#34;:
                if global_ht == 0:
                    global_d = 0.0
                else:
                    global_d = (global_ht - global_hs) / (1 - global_hs) * \
                        (gn / (gn - 1))
            else:
                if loc_agg in (&#34;HARM&#34;, &#34;ADJHARM&#34;):
                    global_d = agg.aggregate_dist(loc_agg, d_vals)
                else:
                    global_d = agg.aggregate_dist(&#34;HARM&#34;, d_vals)
            genmat[ia, ib] = genmat[ib, ia] = global_d

        # elif dist == &#34;GST&#34; or dist == &#34;GSTPRIME&#34;:
        #     HT = list()
        #     HS = list()
        #     for loc in range(0, len(seqs[popmap.values()[ia][-1]])):
        #         seqs1 = get_alleles(
        #             [seqs[x][loc] for x in popmap.values()[ia]]
        #         )
        #         seqs2 = get_alleles(
        #             [seqs[x][loc] for x in popmap.values()[ib]]
        #         )
        #         if (not clean_list(set(seqs1), [&#34;n&#34;, &#34;N&#34;, &#34;-&#34;, &#34;?&#34;]) or
        #                 not clean_list(set(seqs2), [&#34;n&#34;, &#34;N&#34;, &#34;-&#34;, &#34;?&#34;])):
        #             continue
        #         if dist == &#34;GST&#34; or &#34;GSTPRIME&#34;:
        #             (ht, hs) = two_pop_ht_hs(seqs1, seqs2, ploidy,global_het)
        #             HT.append(ht)
        #             HS.append(hs)
        #     Ht_global = np.mean(HT)
        #     Hs_global = np.mean(HS)
        #     if dist == &#34;GST&#34;:
        #         if Ht_global &lt;= 0.0:
        #             genmat[ia, ib] = genmat[ib, ia] = 0.0
        #         Gst = ((Ht_global - Hs_global) / Ht_global)
        #         GprimeST = ((Gst * (1.0 + Hs_global)) / (1.0 - Hs_global))
        #         genmat[ia, ib] = genmat[ib, ia] = GprimeST
        #     elif dist == &#34;GSTPRIME&#34;:
        #         Ghedrick = ((2.0*(Ht_global - Hs_global)) /
        #                     (((2.0*Ht_global) - Hs_global) *
        #                      (1.0 - Hs_global)))
        #         genmat[ia, ib] = genmat[ib, ia] = Ghedrick
        elif dist == &#34;FST&#34; or dist == &#34;LINFST&#34;:
            num = list()  # numerator; a
            denom = list()  # denominator; a*b*c
            for loc in range(0, len(seqs[popmap.values()[ia][-1]])):
                seqs1 = clean_inds([seqs[x][loc] for x in popmap.values()[ia]])
                seqs2 = clean_inds([seqs[x][loc] for x in popmap.values()[ib]])
                if (not all(&#34;/&#34; in x for x in seqs1) or
                        not all(&#34;/&#34; in x for x in seqs2)):
                    print(&#34;ERROR: FST estimates require phased data.&#34;)
                    sys.exit(1)
                if len(seqs1) == 0 or len(seqs2) == 0:
                    continue
                (n, d) = two_pop_weir_cockerham_fst(seqs1, seqs2)
                num.append(n)
                denom.append(d)

            # if either population lacking data, set value to nan
            if len(num) &lt;= 0 or len(denom) &lt;= 0:
                np.nan
            # if denominator is 0, set Fst to 0
            elif np.sum(denom) == 0.0:
                theta = 0.0
            # otherwise, calculate as normal
            else:
                theta = np.sum(num) / np.sum(denom)

            if dist == &#34;FST&#34;:
                genmat[ia, ib] = genmat[ib, ia] = theta
            elif dist == &#34;LINFST&#34;:
                if theta != 1.0:
                    genmat[ia, ib] = genmat[ib, ia] = (theta / (1-theta))
                else:
                    genmat[ia, ib] = genmat[ib, ia] = theta
        # elif dist == &#34;NEI83&#34;:
        #     results = list()
        #     loci = 0.0
        #     for loc in range(0, len(seqs[popmap.values()[ia][-1]])):
        #         seqs1 = get_alleles(
        #             [seqs[x][loc] for x in popmap.values()[ia]]
        #         )
        #         seqs2 = get_alleles(
        #             [seqs[x][loc] for x in popmap.values()[ib]]
        #         )
        #         if (not clean_list(set(seqs1), [&#34;n&#34;, &#34;N&#34;, &#34;-&#34;, &#34;?&#34;]) or
        #                 not clean_list(set(seqs2), [&#34;n&#34;, &#34;N&#34;, &#34;-&#34;, &#34;?&#34;])):
        #             continue
        #         loci += 1.0
        #         results.append(two_pop_nei_da(seqs1, seqs2))
        #     Da = (1.0 - (np.sum(results) / loci))
        #     genmat[ia, ib] = genmat[ib, ia] = Da
        elif dist == &#34;CHORD&#34;:
            sum_squares = 0.0
            for loc in range(0, len(seqs[popmap.values()[ia][-1]])):
                seqs1 = get_alleles(
                    [seqs[x][loc] for x in popmap.values()[ia]])
                seqs2 = get_alleles(
                    [seqs[x][loc] for x in popmap.values()[ib]])

                if (not clean_list(set(seqs1), [&#34;n&#34;, &#34;N&#34;, &#34;-&#34;, &#34;?&#34;]) or
                        not clean_list(set(seqs2), [&#34;n&#34;, &#34;N&#34;, &#34;-&#34;, &#34;?&#34;])):
                    continue

                sq_diff, _ = two_pop_chord_dist(seqs1, seqs2)
                sum_squares += sq_diff
            Dch = np.sqrt(sum_squares)
            genmat[ia, ib] = genmat[ib, ia] = Dch
        else:
            raise ValueError(f&#34;Unsupported distance option {dist}&#34;)
    np.fill_diagonal(genmat, 0.0)
    if 0.0 in genmat:
        print(&#34;WARNING: Coercing negative distances to 0.0&#34;)
        genmat[genmat &lt; 0.0] = 0.0
    return genmat</code></pre>
</details>
</dd>
<dt id="autostreamtree.genetic_distances.hamming_distance"><code class="name flex">
<span>def <span class="ident">hamming_distance</span></span>(<span>seq1, seq2)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the Hamming distance between two sequences.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>seq1</code></strong> :&ensp;<code>str</code></dt>
<dd>First sequence.</dd>
<dt><strong><code>seq2</code></strong> :&ensp;<code>str</code></dt>
<dd>Second sequence.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Hamming distance.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hamming_distance(seq1, seq2):
    &#34;&#34;&#34;
    Calculate the Hamming distance between two sequences.

    Args:
        seq1 (str): First sequence.
        seq2 (str): Second sequence.

    Returns:
        float: Hamming distance.
    &#34;&#34;&#34;
    # Ensure sequences are of equal length
    L = min(len(seq1), len(seq2))
    D = 0.0

    for n1, n2 in zip(seq1.lower(), seq2.lower()):
        if n1 in [&#34;?&#34;, &#34;-&#34;, &#34;n&#34;] or n2 in [&#34;?&#34;, &#34;-&#34;, &#34;n&#34;]:
            L -= 1  # Ignore positions with gaps or ambiguous nucleotides
        elif n1 != n2:
            D += 1.0  # Count mismatches

    if L &lt;= 0:
        return 0.0  # Avoid division by zero
    return D / L</code></pre>
</details>
</dd>
<dt id="autostreamtree.genetic_distances.p_distance"><code class="name flex">
<span>def <span class="ident">p_distance</span></span>(<span>seq1, seq2)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate p-distance, accounting for IUPAC ambiguity codes and partial
matches.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>seq1</code></strong> :&ensp;<code>str</code></dt>
<dd>First sequence.</dd>
<dt><strong><code>seq2</code></strong> :&ensp;<code>str</code></dt>
<dd>Second sequence.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>p-distance.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def p_distance(seq1, seq2):
    &#34;&#34;&#34;
    Calculate p-distance, accounting for IUPAC ambiguity codes and partial
    matches.

    Args:
        seq1 (str): First sequence.
        seq2 (str): Second sequence.

    Returns:
        float: p-distance.
    &#34;&#34;&#34;
    L = min(len(seq1), len(seq2))
    D = 0.0

    for n1, n2 in zip(seq1.lower(), seq2.lower()):
        if n1 in [&#34;?&#34;, &#34;-&#34;, &#34;n&#34;] or n2 in [&#34;?&#34;, &#34;-&#34;, &#34;n&#34;]:
            L -= 1
            continue
        else:
            ex1 = set(seq.get_iupac_caseless(n1))
            ex2 = set(seq.get_iupac_caseless(n2))

            if ex1 == ex2:
                # Exact match
                continue
            elif ex1.isdisjoint(ex2):
                # No match
                D += 1.0
            else:
                # Partial match
                D += 0.5

    if L &lt;= 0:
        return 0.0
    return D / L</code></pre>
</details>
</dd>
<dt id="autostreamtree.genetic_distances.two_pop_chord_dist"><code class="name flex">
<span>def <span class="ident">two_pop_chord_dist</span></span>(<span>s1, s2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def two_pop_chord_dist(s1, s2):
    s1 = clean_list(s1, [&#34;n&#34;, &#34;?&#34;, &#34;-&#34;, &#34;N&#34;])
    s2 = clean_list(s2, [&#34;n&#34;, &#34;?&#34;, &#34;-&#34;, &#34;N&#34;])
    uniques = uniq_alleles(s1 + s2)

    sum_squares = 0.0
    for allele in uniques:
        if allele in [&#34;-&#34;, &#34;?&#34;, &#34;n&#34;, &#34;N&#34;]:
            continue
        Xu = float(s1.count(allele) / len(s1))
        Yu = float(s2.count(allele) / len(s2))
        sum_squares += np.square(Xu - Yu)

    return sum_squares, len(uniques)</code></pre>
</details>
</dd>
<dt id="autostreamtree.genetic_distances.two_pop_jost_d"><code class="name flex">
<span>def <span class="ident">two_pop_jost_d</span></span>(<span>seqs1, seqs2, global_het=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def two_pop_jost_d(seqs1, seqs2, global_het=False):
    if global_het:
        Ht = get_global_het(seqs1 + seqs2)
    else:
        Ht = get_average_het(seqs1, seqs2)
    Hs = np.mean([get_global_het(seqs1), get_global_het(seqs2)])
    n = len(seqs1 + seqs2)
    D = (Ht - Hs) / (1 - Hs) * (n / (n - 1))
    return Hs, Ht, D</code></pre>
</details>
</dd>
<dt id="autostreamtree.genetic_distances.two_pop_weir_cockerham_fst"><code class="name flex">
<span>def <span class="ident">two_pop_weir_cockerham_fst</span></span>(<span>s1, s2)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes Weir and Cockerham's THETAst Fst approximation for two populations</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>s1</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of phased genotypes for population 1.</dd>
<dt><strong><code>s2</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of phased genotypes for population 2.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>A tuple containing two floats. The first float is the numerator</dd>
<dt><code>of the THETAst estimator for the locus. The second float is the</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>denominator of the THETAst estimator for the locus.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the inputs are not valid.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def two_pop_weir_cockerham_fst(s1, s2):
    &#34;&#34;&#34;
    Computes Weir and Cockerham&#39;s THETAst Fst approximation for two populations

    Args:
        s1 (list): A list of phased genotypes for population 1.
        s2 (list): A list of phased genotypes for population 2.

    Returns:
        tuple: A tuple containing two floats. The first float is the numerator
        of the THETAst estimator for the locus. The second float is the
        denominator of the THETAst estimator for the locus.

    Raises:
        ValueError: If the inputs are not valid.

    &#34;&#34;&#34;
    # Check inputs
    if not isinstance(s1, list) or not isinstance(s2, list):
        raise ValueError(&#34;Inputs must be lists.&#34;)
    if not s1 or not s2:
        raise ValueError(&#34;Inputs must not be empty.&#34;)
    if (not all(isinstance(x, str) for x in s1) or
            not all(isinstance(x, str) for x in s2)):
        raise ValueError(&#34;Inputs must only contain strings.&#34;)
    if not all(&#34;/&#34; in x for x in s1) or not all(&#34;/&#34; in x for x in s2):
        raise ValueError(&#34;Inputs must be phased genotypes.&#34;)

    # Initialize variables
    num = 0.0
    denom = 0.0

    # mean sample size
    alleles1 = get_alleles(s1)  # split alleles s1
    alleles2 = get_alleles(s2)  # split alleles s2
    uniques = uniq_alleles(s1+s2)  # list of unique alleles only
    r = 2.0  # number of pops
    n1 = float(len(s1))  # pop size of pop 1
    n2 = float(len(s2))  # pop size of pop 2
    csd = np.std([n1, n2])
    cm = np.mean([n1, n2])
    nbar = cm
    csquare = (csd*csd) / (cm*cm)
    nC = nbar * (1.0 - (csquare/r))  # coeff of pop size variance
    for allele in uniques:
        ac1 = float(alleles1.count(allele))
        ac2 = float(alleles2.count(allele))
        p1 = ac1 / float(len(alleles1))
        p2 = ac2 / float(len(alleles2))
        h1 = get_het_from_phased(allele, s1, count=True)
        h2 = get_het_from_phased(allele, s2, count=True)
        pbar = (ac1+ac2) / (float(len(alleles1)) + float(len(alleles2)))
        ssquare = ((np.sum([(n1 * (np.square(p1 - pbar))),
                            (n2 * (np.square(p2 - pbar)))])) / ((r-1.0)*nbar))
        hbar = ((h1 + h2) / (r * nbar))
        if nbar != 1.0:
            a = ((nbar/nC) * (ssquare -
                              ((1.0 / (nbar-1.0)) *
                               ((pbar * (1.0 - pbar)) -
                                ((r - 1.0) * ssquare / r) -
                                (hbar / 4.0)))))
            b = ((nbar / (nbar-1.0)) *
                 ((pbar * (1.0 - pbar)) -
                  ((r - 1.0) * ssquare / r) -
                  (((2.0 * nbar) - 1.0) * hbar / (4.0 * nbar))))
            c = hbar/2.0
            d = a+b+c
            num += a
            denom += d
    return num, denom</code></pre>
</details>
</dd>
<dt id="autostreamtree.genetic_distances.uniq_alleles"><code class="name flex">
<span>def <span class="ident">uniq_alleles</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the unique alleles in a list of alleles.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of alleles.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>set</code></dt>
<dd>A set of unique alleles.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def uniq_alleles(s):
    &#34;&#34;&#34;Returns the unique alleles in a list of alleles.

    Args:
        s (list): A list of alleles.

    Returns:
        set: A set of unique alleles.
    &#34;&#34;&#34;
    return set(sum([x.split(&#34;/&#34;) for x in s], []))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="autostreamtree" href="index.html">autostreamtree</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="autostreamtree.genetic_distances.clean_inds" href="#autostreamtree.genetic_distances.clean_inds">clean_inds</a></code></li>
<li><code><a title="autostreamtree.genetic_distances.clean_list" href="#autostreamtree.genetic_distances.clean_list">clean_list</a></code></li>
<li><code><a title="autostreamtree.genetic_distances.get_alleles" href="#autostreamtree.genetic_distances.get_alleles">get_alleles</a></code></li>
<li><code><a title="autostreamtree.genetic_distances.get_average_het" href="#autostreamtree.genetic_distances.get_average_het">get_average_het</a></code></li>
<li><code><a title="autostreamtree.genetic_distances.get_genmat" href="#autostreamtree.genetic_distances.get_genmat">get_genmat</a></code></li>
<li><code><a title="autostreamtree.genetic_distances.get_global_het" href="#autostreamtree.genetic_distances.get_global_het">get_global_het</a></code></li>
<li><code><a title="autostreamtree.genetic_distances.get_het_from_phased" href="#autostreamtree.genetic_distances.get_het_from_phased">get_het_from_phased</a></code></li>
<li><code><a title="autostreamtree.genetic_distances.get_pop_genmat" href="#autostreamtree.genetic_distances.get_pop_genmat">get_pop_genmat</a></code></li>
<li><code><a title="autostreamtree.genetic_distances.hamming_distance" href="#autostreamtree.genetic_distances.hamming_distance">hamming_distance</a></code></li>
<li><code><a title="autostreamtree.genetic_distances.p_distance" href="#autostreamtree.genetic_distances.p_distance">p_distance</a></code></li>
<li><code><a title="autostreamtree.genetic_distances.two_pop_chord_dist" href="#autostreamtree.genetic_distances.two_pop_chord_dist">two_pop_chord_dist</a></code></li>
<li><code><a title="autostreamtree.genetic_distances.two_pop_jost_d" href="#autostreamtree.genetic_distances.two_pop_jost_d">two_pop_jost_d</a></code></li>
<li><code><a title="autostreamtree.genetic_distances.two_pop_weir_cockerham_fst" href="#autostreamtree.genetic_distances.two_pop_weir_cockerham_fst">two_pop_weir_cockerham_fst</a></code></li>
<li><code><a title="autostreamtree.genetic_distances.uniq_alleles" href="#autostreamtree.genetic_distances.uniq_alleles">uniq_alleles</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>